# -*- coding:utf-8 -*-import sys,os,os.path,time,struct,traceback,threading,datetime,calendar,stringfrom xml.dom import getDOMImplementationimport sqlite3import string,hashlibimport json,uuid,base64GCONFS={	'auth_public_keyfile':'public.rsa',    'auth_private_keyfile':'private.rsa'}def encrypt_des(key,text):	from Crypto.Cipher import DES	import base64	from Crypto import Random	#iv = Random.get_random_bytes(8)	des = DES.new(key, DES.MODE_ECB)	reminder = len(text)%8	if reminder ==0:  # pad 8 bytes		text+='\x08'*8	else:		text+=chr(8-reminder)* (8-reminder)	#text+=' '*(8-len(text)%8)	return des.encrypt(text)#return base64.encodestring(des.encrypt(text))def decrypt_des(key,text):	from Crypto.Cipher import DES	import base64	#	print key	des = DES.new(key, DES.MODE_ECB)	text = des.decrypt(text)	pad = ord(text[-1])	if pad == '\x08':		return text[:-8]	return text[:-pad]def rsa_generate():	from Crypto.PublicKey import RSA	from Crypto import Random	random_generator = Random.new().read	key = RSA.generate(1024, random_generator)	#print key.publickey().encrypt('123213213123213213',20)	public =  key.publickey().exportKey()	#print key.publickey().exportKey()	private = key.exportKey()	return public,privatedef rsa_encrypt(key,text):	import uuid	from Crypto.PublicKey import RSA	deskey = hashlib.md5(uuid.uuid1().hex).hexdigest()[:8]	text = encrypt_des(deskey,text)	key = RSA.importKey(key)	r = key.encrypt(deskey,32)	return r[0]+text # 加密的key，和des加密的数据def rsa_decrypt(key,text):	from Crypto.PublicKey import RSA	try:		rsa = RSA.importKey(key)		deskey = text[:128]		text = text[128:]		deskey = rsa.decrypt(deskey)		return decrypt_des(deskey,text)	except:		return ''class Cipher:	def __init__(self):#		self.pubkey = pubkey#		self.privkey = privkey		pass	def encrypt(self,key,text):		return rsa_encrypt(key,text)	def decrypt(self,key,text):		return rsa_decrypt(key,text)	@staticmethod	def getCipher():		try:			cip = Cipher()			return cip		except:			traceback.print_exc()			return Nonedef encryptInvoices(key,user):	'''	'''	d = ''	try:		d = json.dumps(user)		d = Cipher.getCipher().encrypt(key,d)		d = base64.encodestring(d).strip()	except:		print traceback.format_exc()		d = ''	return ddef decryptToken(key,d):	user = None	try:		d = base64.decodestring(d)		d = Cipher.getCipher().decrypt(key,d)		user = json.loads(d)	except:		#print traceback.format_exc()		pass	return userLICENSE_KEY='sw2uscom'def encrypt_bankaccount(bank,outfile='tax.lic'):	'''		bank (unicode)		将开票方的银行账号加密写到tax.lic文件		开发票时将tax.lic的银行账号送入开票信息,这样便能控制软件拷贝给其他客户使用了，		因为客户的银行账号都是不同的，而生成tax.lic的方法只有我能控制	'''	print bank	props={'bankacct':bank}	d = json.dumps(props)	s = encrypt_des(LICENSE_KEY,d)	f = open(outfile,'wb')	f.write(s)	f.close()	print 'written tax.lic'def decrypt_bankaccount(inputfile='tax.lic'):	'''		return( unicode )	'''	try:		f = open('tax.lic','rb')		d = f.read()		f.close()		d = decrypt_des(LICENSE_KEY,d)		s = json.loads(d)		return s['bankacct']	except:		return ''if __name__=='__main__':	#encrypt_bankaccount(u'工行123455668-234222256111')	#encrypt_bankaccount(u'农行施湾分理处03784900040004341')		print decrypt_bankaccount(r'F:\tax_install\tax.lic')